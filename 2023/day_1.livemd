# advent of code

```elixir
Mix.install([
  {:kino, "~> 0.12.0"}
])

input = Kino.Input.textarea("input")
```

## part 1

```elixir
calibrations =
  Kino.Input.read(input)
  |> String.split("\n", trim: true)
```

```elixir
calibrations
|> Enum.map(fn calibration ->
  only_number_string = Regex.replace(~r/[^\d]/, calibration, "")
  first = only_number_string |> String.at(0)
  last = only_number_string |> String.at(-1)

  "#{first}#{last}" |> String.to_integer()
end)
|> Enum.sum()
```

## part2

```elixir
defmodule Day01.Part2.Solve1 do
  @number_words ["one", "two", "three", "four", "five", "six", "seven", "eight", "nine"]
                |> Enum.with_index(1)
  @number_strings 1..9 |> Enum.map(&{Integer.to_string(&1), &1})

  @number_matches @number_words ++ @number_strings

  def recover(calibration) do
    do_recover(calibration, [])
    |> Enum.reverse()
    |> then(&("#{List.first(&1)}#{List.last(&1)}" |> String.to_integer()))
  end

  # 마지막에 돌아가는 함수
  def do_recover("", result) do
    result
  end

  def do_recover(calibration, result) do
    new_result =
      @number_matches
      |> Enum.find_value(fn {number_match, number} ->
        case calibration |> String.starts_with?(number_match) do
          true -> number
          false -> nil
        end
      end)
      |> case do
        nil -> result
        number -> [number | result]
      end

    do_recover(calibration |> String.slice(1..-1), new_result)
  end
end

calibrations
|> Enum.map(fn calibration ->
  Day01.Part2.Solve1.recover(calibration)
end)
|> Enum.sum()
```
