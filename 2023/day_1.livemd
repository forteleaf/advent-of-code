# advent of code

```elixir
Mix.install([
  {:kino, "~> 0.12.0"}
])

input = Kino.Input.textarea("input")
```

## part 1

```elixir
calibrations =
  Kino.Input.read(input)
  |> String.split("\n")
```

```elixir
calibrations
|> Enum.map(fn calibration ->
  only_number_string = Regex.replace(~r/[^\d]/, calibration, "")
  first = only_number_string |> String.at(0)
  last = only_number_string |> String.at(-1)

  "#{first}#{last}" |> String.to_integer()
end)
|> Enum.sum()
```

## part2

```elixir
defmodule Day01.Part2.Solve1 do
  def recover(calibration) do
    do_recover(calibration, [])
  end

  # 마지막에 돌아가는 함수
  def do_recover("", result) do
    result
  end

  defp do_recover(calibration, result) do
    ["one", "two", "three", "four", "five", "six", "seven", "eight", "nine"]
    |> Enum.with_index(1)
    |> IO.inspect()

    new_result =
      case calibration |> String.starts_with?("one") do
        true -> [1 | result]
        false -> result
      end

    do_recover(calibration |> String.slice(1..-1), new_result)
  end

  defp digits_word_to_number(digits) do
    digit_map = %{
      "one" => "1",
      "two" => "2",
      "three" => "3",
      "four" => "4",
      "five" => "5",
      "six" => "6",
      "seven" => "7",
      "eight" => "8",
      "nine" => "9"
    }

    digits
    |> Enum.map(fn digit ->
      cond do
        Map.has_key?(digit_map, digit) -> digit_map[digit]
        true -> digit
      end
    end)
  end
end

calibrations
|> Enum.map(fn calibration ->
  Day01.Part2.Solve1.recover(calibration)
end)
```
